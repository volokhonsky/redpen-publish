<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>RedPen — Красной ручкой</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <link rel="stylesheet" href="../css/main.css">
  <link rel="stylesheet" href="../css/components.css">
  <link rel="stylesheet" href="../css/responsive.css">
  <link rel="icon" href="../favicon.svg">
  <style>
    .home-button {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      background-color: #DC143C;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      text-decoration: none;
      font-weight: bold;
      font-size: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      transition: background-color 0.2s;
    }
    .home-button:hover {
      background-color: #b01030;
    }
  </style>
</head>
<body>
  <a href="../index.html" class="home-button" title="Вернуться к выбору документов">⌂</a>
  <header>RedPen — Красной ручкой <span id="timestamp" style="font-size: 0.7rem; font-weight: normal; opacity: 0.8;">Последнее обновление: 15.05.2023 14:30</span></header>
  <nav>
    <a href="#" onclick="loadPage(7);return false;">Стр. 7</a>
    <a href="#" onclick="loadPage(8);return false;">Стр. 8</a>
    <a href="#" onclick="loadPage(9);return false;">Стр. 9</a>
    <a href="#" onclick="loadPage(10);return false;">Стр. 10</a>
    <a href="#" onclick="loadPage(11);return false;">Стр. 11</a>
    <a href="#" onclick="loadPage(12);return false;">Стр. 12</a>
  </nav>
  <div id="layout">
    <div id="content-wrapper">
      <div id="image-container">
        <img id="page-image"/>
      </div>
      <div id="comments-content">
        <h2>Комментарии</h2>
        <ul id="comment-list"></ul>
      </div>
    </div>
    <div id="global-comment-container">
      <h2>Общий комментарий</h2>
      <div id="global-comment">Загрузка...</div>
    </div>
  </div>

  <!-- Mobile comment overlay -->
  <div id="mobile-overlay" class="mobile-overlay">
    <div class="mobile-overlay-close" onclick="closeMobileOverlay()">×</div>
    <div class="mobile-comment-content" id="mobile-comment-content"></div>
  </div>

  <script src="../js/layout.js"></script>
  <script src="../js/annotations.js"></script>
  <script src="../js/mobile.js"></script>
  <script>
    // Get the document ID from the URL path
    const pathParts = window.location.pathname.split('/');
    const documentId = pathParts[pathParts.length - 2] || 'med1'; // Default to med1 if not found
    
    /**
     * Initialize the application
     */
    function init() {
      // Set initial mobile flag
      isMobile = checkMobile();

      // Add event listener for window resize
      window.addEventListener('resize', function() {
        isMobile = checkMobile();
        updateLayout();

        // Debounce the annotation repositioning to prevent too many updates during resizing
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
          repositionAnnotations();
        }, 250); // Wait 250ms after resize ends before repositioning
      });

      // Load the initial page
      loadPage(7);
      
      // Update the page title with the document ID
      document.title = `RedPen — ${documentId === 'med1' ? 'Медицинский документ 1' : 'Медицинский документ 2'}`;
    }

    /**
     * Load a page with the given page number
     * @param {number} pageNum - The page number to load
     */
    async function loadPage(pageNum) {
      // Set mobile flag
      isMobile = checkMobile();

      // Close mobile overlay if it's open
      closeMobileOverlay();

      // Remove any existing comment popups and circles
      document.querySelectorAll('.comment-popup').forEach(popup => popup.remove());
      document.querySelectorAll('.circle').forEach(circle => circle.remove());

      // Always ensure image container is visible from the start
      document.getElementById('image-container').style.display = 'flex';

      // Always ensure global comment container is visible from the start
      document.getElementById('global-comment-container').style.display = 'block';

      currentPageId = 'page_' + String(pageNum).padStart(3,'0');
      const img = document.getElementById('page-image');
      
      // Update image path to include document ID
      img.src = `../images/${currentPageId}.png`;

      // Wait for image to load
      await new Promise(r => {
        img.onload = r;
      });

      // Add a small delay to ensure the image is fully rendered
      await new Promise(resolve => setTimeout(resolve, 50));

      if (overlayContainer) overlayContainer.remove();
      overlayContainer = document.createElement('div');
      overlayContainer.id = 'overlay-container';
      overlayContainer.style.top  = img.offsetTop + 'px';
      overlayContainer.style.left = img.offsetLeft + 'px';
      overlayContainer.style.width  = img.width  + 'px';
      overlayContainer.style.height = img.height + 'px';
      overlayContainer.style.pointerEvents = 'auto';

      // Force image container to be visible again
      const imageContainer = document.getElementById('image-container');
      imageContainer.style.display = 'flex';
      imageContainer.appendChild(overlayContainer);

      // Update layout based on image width
      updateLayout();

      // Double-check layout after a short delay
      setTimeout(updateLayout, 100);

      // Load annotations with document ID in the path
      try {
        allAnns = await fetch(`../annotations/${currentPageId}.json`).then(r=>r.json());
      } catch(e){ allAnns = [] }

      // Global comment
      const globalDiv = document.getElementById('global-comment');
      const globalContainer = document.getElementById('global-comment-container');
      const generalAnns = allAnns.filter(a=>a.annType==='general');
      const mainAnns = allAnns.filter(a=>a.annType==='main');

      // Force global comment container to be visible
      globalContainer.style.display = 'block';

      // Build the global comment content
      let globalContent = '';

      // Add general comments first
      if (generalAnns.length) {
        globalContent += generalAnns.map(a => '<p>' + a.text + '</p>').join('');
      }

      // Add main comments, each with a number
      if (mainAnns.length) {
        globalContent += mainAnns.map((a,i) => '<p><strong>'+(i+1)+'.</strong> '+a.text+'</p>').join('');
      }

      if (globalContent) {
        globalDiv.innerHTML = globalContent;
      } else {
        globalDiv.textContent = 'Нет общего комментария.';
      }

      const listUl = document.getElementById('comment-list');
      listUl.innerHTML = '';

      // Position annotations using the repositionAnnotations function
      repositionAnnotations();
      
      // Update URL hash for direct linking
      window.location.hash = `page${pageNum}`;
    }

    // Override the repositionAnnotations function to use the correct paths
    const originalRepositionAnnotations = repositionAnnotations;
    repositionAnnotations = function() {
      if (!overlayContainer || !currentPageId || allAnns.length === 0) return;

      const img = document.getElementById('page-image');
      if (!img.complete) return;

      // Calculate scale factors
      const originalWidth = img.naturalWidth;
      const originalHeight = img.naturalHeight;
      const scaleX = img.width / originalWidth;
      const scaleY = img.height / originalHeight;

      // Update overlay container size and position
      overlayContainer.style.width = img.width + 'px';
      overlayContainer.style.height = img.height + 'px';
      overlayContainer.style.top = img.offsetTop + 'px';
      overlayContainer.style.left = img.offsetLeft + 'px';

      // Remove existing circles and popups
      document.querySelectorAll('.circle').forEach(circle => circle.remove());
      document.querySelectorAll('.comment-popup').forEach(popup => popup.remove());

      // Recreate circles and popups with updated positions
      const sizeMap = { main: 100, comment: 50, small: 25 };

      // Load text blocks with document ID in the path
      let textBlocks = {};
      fetch(`../text/${currentPageId}.json`)
        .then(r => {
          if (!r.ok) {
            throw new Error(`Failed to fetch text blocks: ${r.status} ${r.statusText}`);
          }
          return r.json();
        })
        .then(tl => {
          tl.forEach(b => {
            const [x0, y0, x1, y1] = b.bbox.map(v => v * 2);
            textBlocks[b.id] = [x0, y0, x1, y1];
          });

          // Filter out general comments for separate processing
          const generalComments = allAnns.filter(a => a.annType === 'general');
          const nonGeneralComments = allAnns.filter(a => a.annType !== 'general');

          // Create circles and popups for non-general comments
          nonGeneralComments.forEach((a, i) => {
            let cx, cy;
            const bb = textBlocks[a.targetBlock];

            if (bb) {
              // Apply scale factor to the bounding box coordinates
              const scaledBB = [
                bb[0] * scaleX,
                bb[1] * scaleY,
                bb[2] * scaleX,
                bb[3] * scaleY
              ];
              [cx, cy] = [scaledBB[2], (scaledBB[1] + scaledBB[3]) / 2];
            } else if (a.coords) {
              // Apply scale factor to the fallback coordinates
              [cx, cy] = [a.coords[0] * scaleX, a.coords[1] * scaleY];
            } else {
              return;
            }

            const d = sizeMap[a.annType] || 50;
            const circle = document.createElement('div');
            circle.className = 'circle';
            circle.id = 'circle-' + (a.id || `${currentPageId}-${i+1}`);
            circle.style.width = d + 'px';
            circle.style.height = d + 'px';
            circle.style.left = cx + 'px';
            circle.style.top = cy - d / 2 + 'px';
            const color = a.annType === 'main' ? '#DC143C' : '#0000FF';
            circle.style.background = `radial-gradient(circle, ${color}80 0%, ${color}40 50%, ${color}00 100%)`;
            circle.style.fontSize = (d * 0.6) + 'px';
            circle.style.transform = 'translateX(-50%)';
            circle.textContent = i + 1;

            // Use only this comment's text
            let commentText = a.text;

            // Create popup for desktop hover
            const popup = document.createElement('div');
            popup.className = 'comment-popup';
            popup.id = (a.id || `ann-${currentPageId}-${i+1}`);
            popup.innerHTML = `
              <div class="comment-popup-title">Комментарий ${i + 1}</div>
              <div>${commentText}</div>
            `;
            popup.style.left = cx + 'px';
            popup.style.top = (cy + d / 2 + 10) + 'px';
            popup.style.transform = 'translateX(-50%)';
            popup.dataset.hoverShown = 'false';
            popup.dataset.clickShown = 'false';
            overlayContainer.appendChild(popup);

            // Prevent popup from closing when clicking on it
            popup.addEventListener('click', (e) => {
              e.stopPropagation();
            });

            // Desktop: Show popup on hover
            if (!isMobile) {
              circle.addEventListener('mouseenter', () => {
                // Only show on hover if not already shown by click
                if (popup.dataset.clickShown !== 'true') {
                  popup.style.display = 'block';
                  popup.dataset.hoverShown = 'true';
                }
              });

              circle.addEventListener('mouseleave', () => {
                // Only hide on mouse leave if it was shown by hover, not by click
                if (popup.dataset.hoverShown === 'true' && popup.dataset.clickShown !== 'true') {
                  popup.style.display = 'none';
                  popup.dataset.hoverShown = 'false';
                }
              });
            }

            // Handle click events
            circle.addEventListener('click', (e) => {
              if (isMobile) {
                // Mobile: Show overlay
                showMobileComment(i, commentText);
              } else {
                // Desktop: Update sidebar list and show popup
                const listUl = document.getElementById('comment-list');
                listUl.innerHTML = '';
                const li = document.createElement('li');
                li.innerHTML = '<strong>' + (i + 1) + '.</strong> ' + commentText;
                listUl.appendChild(li);

                // Reset all popups' click-shown state
                document.querySelectorAll('.comment-popup').forEach(p => {
                  p.dataset.clickShown = 'false';
                  if (p !== popup) p.style.display = 'none';
                });

                // Show this popup and mark it as shown by click
                popup.style.display = 'block';
                popup.dataset.clickShown = 'true';

                // Stop propagation to prevent the document click handler from immediately hiding it
                e.stopPropagation();
              }
            });

            overlayContainer.appendChild(circle);
          });

          // Add document-level click event to hide all popups when clicking elsewhere
          if (!isMobile) {
            // Remove any existing document click listener first to avoid duplicates
            document.removeEventListener('click', hideAllPopups);

            // Add new document click listener
            document.addEventListener('click', hideAllPopups);
          }
        })
        .catch(e => {
          console.error('Error repositioning annotations:', e);
          // Try to create annotations using fallback coordinates even if text blocks failed to load
          if (allAnns && allAnns.length > 0) {
            // Filter out general comments for separate processing
            const generalComments = allAnns.filter(a => a.annType === 'general');
            const nonGeneralComments = allAnns.filter(a => a.annType !== 'general');

            nonGeneralComments.forEach((a, i) => {
              if (a.coords) {
                const cx = a.coords[0] * scaleX;
                const cy = a.coords[1] * scaleY;

                const d = sizeMap[a.annType] || 50;
                const circle = document.createElement('div');
                circle.className = 'circle';
                circle.id = 'circle-' + (a.id || `${currentPageId}-${i+1}`);
                circle.style.width = d + 'px';
                circle.style.height = d + 'px';
                circle.style.left = cx + 'px';
                circle.style.top = cy - d / 2 + 'px';
                const color = a.annType === 'main' ? '#DC143C' : '#0000FF';
                circle.style.background = `radial-gradient(circle, ${color}80 0%, ${color}40 50%, ${color}00 100%)`;
                circle.style.fontSize = (d * 0.6) + 'px';
                circle.textContent = i + 1;

                // Use only this comment's text
                let commentText = a.text;

                const popup = document.createElement('div');
                popup.className = 'comment-popup';
                popup.id = (a.id || `ann-${currentPageId}-${i+1}`);
                popup.innerHTML = `
                  <div class="comment-popup-title">Комментарий ${i + 1}</div>
                  <div>${commentText}</div>
                `;
                popup.style.left = cx + 'px';
                popup.style.top = (cy + d / 2 + 10) + 'px';
                popup.dataset.hoverShown = 'false';
                popup.dataset.clickShown = 'false';

                overlayContainer.appendChild(popup);
                overlayContainer.appendChild(circle);

                // Add click event handler for mobile
                circle.addEventListener('click', (e) => {
                  if (isMobile) {
                    // Mobile: Show overlay with combined text
                    showMobileComment(i, commentText);
                  } else {
                    // Desktop: Update sidebar list and show popup
                    const listUl = document.getElementById('comment-list');
                    listUl.innerHTML = '';
                    const li = document.createElement('li');
                    li.innerHTML = '<strong>' + (i + 1) + '.</strong> ' + commentText;
                    listUl.appendChild(li);

                    // Reset all popups' click-shown state
                    document.querySelectorAll('.comment-popup').forEach(p => {
                      p.dataset.clickShown = 'false';
                      if (p !== popup) p.style.display = 'none';
                    });

                    // Show this popup and mark it as shown by click
                    popup.style.display = 'block';
                    popup.dataset.clickShown = 'true';

                    // Stop propagation to prevent the document click handler from immediately hiding it
                    e.stopPropagation();
                  }
                });
              }
            });
          }
        });
    };

    // Check if there's a hash in the URL for direct linking
    function checkUrlHash() {
      const hash = window.location.hash;
      if (hash && hash.startsWith('#page')) {
        const pageNum = parseInt(hash.substring(5));
        if (!isNaN(pageNum) && pageNum >= 7 && pageNum <= 12) {
          loadPage(pageNum);
          return true;
        }
      }
      return false;
    }

    // Initialize the application when the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Global variables
      overlayContainer = null;
      currentPageId = null;
      allAnns = [];
      isMobile = false;
      resizeTimeout = null;
      
      // Check for hash in URL or initialize normally
      if (!checkUrlHash()) {
        init();
      }
      
      // Listen for hash changes
      window.addEventListener('hashchange', checkUrlHash);
    });
  </script>
</body>
</html>